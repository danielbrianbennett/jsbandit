beta <- 20
# create containers
transitionProb <- vector(mode = "integer", length = nBandits)
likelihood <- vector(mode = "integer", length = nBandits)
tempProb <- vector(mode = "integer", length = nBandits)
beliefArray <- array(data = 0.5, dim = c(nBandits,nTrials+1,nBlocks))
allChoiceProb <- array(dim = c(nBandits,nTrials,nBlocks))
choiceProb <- matrix(0,nrow = nBlocks, ncol = nTrials)
for (iBlock in 1:nBlocks){
for (iTrial in 2:(nTrials+1)){
for (iState in 1:nBandits){ # loop through current states
# first loop to calculate main integral
for (iPrevState in 1:nBandits){
# calculate transition probability
if (iPrevState == iState){
transitionProb[iPrevState] <- gamma
} else if (iPrevState != iState){
transitionProb[iPrevState] <- 1 - gamma
}
# second loop to calculate integral in denominator
for (iiPrevState in 1:nBandits) {
if ( (points[iBlock,iTrial-1] == winAmount) & (iiPrevState == choices[iBlock,iTrial-1] + 1) ){
likelihood[iiPrevState] <- 0.5 + (0.5 * c)
} else if ( (points[iBlock,iTrial-1] == lossAmount) & (iiPrevState == choices[iBlock,iTrial-1] + 1) ){
likelihood[iiPrevState] <- 0.5 + (0.5 * -d)
} else if ( (points[iBlock,iTrial-1] == winAmount) & (iiPrevState != choices[iBlock,iTrial-1] + 1) ) {
likelihood[iiPrevState] <- 0.5 + (0.5 * -c)
} else if ( (points[iBlock,iTrial-1] == lossAmount) & (iiPrevState != choices[iBlock,iTrial-1] + 1) ) {
likelihood[iiPrevState] <- 0.5 + (0.5 * d)
}
}
tempProb[iPrevState] <- transitionProb[iPrevState] * ( (likelihood[iPrevState] * beliefArray[iPrevState,iTrial-1,iBlock]) / ((likelihood[1] * beliefArray[1,iTrial-1,iBlock]) + (likelihood[2] * beliefArray[2,iTrial-1,iBlock])) )
}
beliefArray[iState,iTrial,iBlock] <- sum(tempProb)
}
for (iState in 1:nBandits) {
allChoiceProb[iState,iTrial-1,iBlock] <- exp(beta * beliefArray[iState,iTrial-1,iBlock]) / sum(exp(beta * beliefArray[,iTrial-1,iBlock]))
}
choiceProb[iBlock,iTrial-1] <- allChoiceProb[choices[iBlock,iTrial-1] + 1,iTrial-1,iBlock]
}
}
beliefArray
cbind(beliefArray[,,1])
cbind(beliefArray[1,,1])
cbind(beliefArray[1,,1], beliefArray[2,,1])
choices
choices[1,]
cbind(beliefArray[1,,1], beliefArray[2,,1],choices[1,])
cbind(beliefArray[1,2:41,1], beliefArray[2,2:41,1],choices[1,])
cbind(beliefArray[1,2:41,1], beliefArray[2,2:41,1],choices[1,],points[1,])
display <- cbind(beliefArray[1,2:41,1], beliefArray[2,2:41,1],choices[1,],points[1,])
View(display)
View(display)
install.packages('devtools')
devtools::install_github('IRkernel/IRkernel')
IRkernel::installspec()  # to register the kernel in the current R installation
IRkernel::installspec()  # to register the kernel in the current R installation
IRkernel::installspec()  # to register the kernel in the current R installation
devtools::install_github('IRkernel/IRkernel')
IRkernel::installspec()  # to register the kernel in the current R installation
# clear workspace:
rm(list=ls())
# load rjags package
library(rstan)
library(tictoc)
# set a couple of helpful variables
participantNumbers <- 21:22 # which participants' data to test?
nTrials <- 30 # per block
nBlocks <- 3
nBandits <- 4
# mean0 <- 20
# variance0 <- 1000
sigma_zeta <- 5
# define working directory and datafile
dataDir <- "~/Documents/Git/jsbandit/data/"
dataFile <- "banditData_v2point2.RData"
stanFile <- "/Users/danielbennett/Documents/Git/jsbandit/analysis/models/stan/bandit_stan_group_optim.stan"
# set working directory and load file
setwd(dataDir)
load(dataFile)
# recode choices from string to numeric
try(sorted.data[sorted.data$choice == "top",]$choice <- 1)
try(sorted.data[sorted.data$choice == "right",]$choice <- 2)
try(sorted.data[sorted.data$choice == "bottom",]$choice <- 3)
try(sorted.data[sorted.data$choice == "left",]$choice <- 4)
sorted.data$choice <- as.numeric(sorted.data$choice)
try(sorted.data[sorted.data$whichFilled == "none",]$whichFilled <- 0)
try(sorted.data[sorted.data$whichFilled == "top",]$whichFilled <- 1)
try(sorted.data[sorted.data$whichFilled == "right",]$whichFilled <- 2)
try(sorted.data[sorted.data$whichFilled == "bottom",]$whichFilled <- 3)
try(sorted.data[sorted.data$whichFilled == "left",]$whichFilled <- 4)
sorted.data$whichFilled <- as.numeric(sorted.data$whichFilled)
# extract the specified participant
IDs <- unique(sorted.data$ID)
subsetID <- IDs[participantNumbers]
extract <- subset(sorted.data, ID %in% subsetID)
nSubjects = length(participantNumbers)
# create data containers to pass to stan, and fill them
choices <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # choice data
points <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # points data
changeLag <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # change lag data
whichFilled <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # which changed data
# deal data to the arrays built above
for (p in 1:nSubjects){
choices[,,p] <- matrix(extract[extract$ID == subsetID[p],]$choice,nBlocks,nTrials,byrow = T)
points[,,p] <- matrix(extract[extract$ID == subsetID[p],]$pointsWon,nBlocks,nTrials,byrow = T)
changeLag[,,p] <- matrix(extract[extract$ID == subsetID[p],]$changeLag,nBlocks,nTrials,byrow = T)
whichFilled[,,p] <- matrix(extract[extract$ID == subsetID[p],]$whichFilled,nBlocks,nTrials,byrow = T)
}
# list data to be passed on to stan
data <- list(choices = choices,
whichFilled = whichFilled,
points = points,
nBandits = nBandits,
nBlocks = nBlocks,
nTrials = nTrials,
nSubjects = nSubjects,
# mean0 = mean0,
# variance0 = variance0,
changeLag = changeLag,
sigma_zeta = sigma_zeta
)
# list parameters to estimate in stan
parameters <- c("mu_sigma_epsilon",
"mu_b",
"mu_p",
"mu_q",
"mu_beta",
"sigma_sigma_epsilon",
"sigma_b",
"sigma_p",
"sigma_q",
"sigma_beta",
"sigma_epsilon",
"b",
"p",
"q",
"beta",
"mean0",
"variance0"
)
# set parallel options
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# set inits
myInits <- list(list(
mu_sigma_epsilon = 5,
mu_b = 5,
mu_p = 5,
mu_q = 5,
mu_beta = 5,
sigma_sigma_epsilon = 10,
sigma_b = 10,
sigma_p = 10,
sigma_q = 10,
sigma_beta = 1,
mean0 = 50,
variance0 = 1000
))
# Call stan
tic()
samples <- stan(file = stanFile,
data = data,
#init = myInits,  # If not specified, gives random inits
pars=parameters,
iter=500,
chains=1,
thin=1
# warmup = 100  # Stands for burn-in; Default = iter/2
# seed = 123  # Setting seed; Default is random seed
)
toc()
# clear workspace:
rm(list=ls())
# load rjags package
library(rstan)
library(tictoc)
# set a couple of helpful variables
participantNumbers <- 21:22 # which participants' data to test?
nTrials <- 30 # per block
nBlocks <- 3
nBandits <- 4
# mean0 <- 20
# variance0 <- 1000
sigma_zeta <- 5
# define working directory and datafile
dataDir <- "~/Documents/Git/jsbandit/data/"
dataFile <- "banditData_v2point2.RData"
stanFile <- "/Users/danielbennett/Documents/Git/jsbandit/analysis/models/stan/bandit_stan_group_optim.stan"
# set working directory and load file
setwd(dataDir)
load(dataFile)
# recode choices from string to numeric
try(sorted.data[sorted.data$choice == "top",]$choice <- 1)
try(sorted.data[sorted.data$choice == "right",]$choice <- 2)
try(sorted.data[sorted.data$choice == "bottom",]$choice <- 3)
try(sorted.data[sorted.data$choice == "left",]$choice <- 4)
sorted.data$choice <- as.numeric(sorted.data$choice)
try(sorted.data[sorted.data$whichFilled == "none",]$whichFilled <- 0)
try(sorted.data[sorted.data$whichFilled == "top",]$whichFilled <- 1)
try(sorted.data[sorted.data$whichFilled == "right",]$whichFilled <- 2)
try(sorted.data[sorted.data$whichFilled == "bottom",]$whichFilled <- 3)
try(sorted.data[sorted.data$whichFilled == "left",]$whichFilled <- 4)
sorted.data$whichFilled <- as.numeric(sorted.data$whichFilled)
# extract the specified participant
IDs <- unique(sorted.data$ID)
subsetID <- IDs[participantNumbers]
extract <- subset(sorted.data, ID %in% subsetID)
nSubjects = length(participantNumbers)
# create data containers to pass to stan, and fill them
choices <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # choice data
points <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # points data
changeLag <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # change lag data
whichFilled <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # which changed data
# deal data to the arrays built above
for (p in 1:nSubjects){
choices[,,p] <- matrix(extract[extract$ID == subsetID[p],]$choice,nBlocks,nTrials,byrow = T)
points[,,p] <- matrix(extract[extract$ID == subsetID[p],]$pointsWon,nBlocks,nTrials,byrow = T)
changeLag[,,p] <- matrix(extract[extract$ID == subsetID[p],]$changeLag,nBlocks,nTrials,byrow = T)
whichFilled[,,p] <- matrix(extract[extract$ID == subsetID[p],]$whichFilled,nBlocks,nTrials,byrow = T)
}
# list data to be passed on to stan
data <- list(choices = choices,
whichFilled = whichFilled,
points = points,
nBandits = nBandits,
nBlocks = nBlocks,
nTrials = nTrials,
nSubjects = nSubjects,
# mean0 = mean0,
# variance0 = variance0,
changeLag = changeLag,
sigma_zeta = sigma_zeta
)
# list parameters to estimate in stan
parameters <- c("mu_sigma_epsilon",
"mu_b",
"mu_p",
"mu_q",
"mu_beta",
"sigma_sigma_epsilon",
"sigma_b",
"sigma_p",
"sigma_q",
"sigma_beta",
"sigma_epsilon",
"b",
"p",
"q",
"beta",
"mean0",
"variance0"
)
# set parallel options
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# set inits
myInits <- list(list(
mu_sigma_epsilon = 5,
mu_b = 5,
mu_p = 5,
mu_q = 5,
mu_beta = 5,
sigma_sigma_epsilon = 10,
sigma_b = 10,
sigma_p = 10,
sigma_q = 10,
sigma_beta = 1,
mean0 = 50,
variance0 = 1000
))
# Call stan
tic()
samples <- stan(file = stanFile,
data = data,
#init = myInits,  # If not specified, gives random inits
pars=parameters,
iter=500,
chains=1,
thin=1
# warmup = 100  # Stands for burn-in; Default = iter/2
# seed = 123  # Setting seed; Default is random seed
)
toc()
# clear workspace:
rm(list=ls())
# load rjags package
library(rstan)
library(tictoc)
# set a couple of helpful variables
participantNumbers <- 21:22 # which participants' data to test?
nTrials <- 30 # per block
nBlocks <- 3
nBandits <- 4
# mean0 <- 20
# variance0 <- 1000
sigma_zeta <- 5
# define working directory and datafile
dataDir <- "~/Documents/Git/jsbandit/data/"
dataFile <- "banditData_v2point2.RData"
stanFile <- "/Users/danielbennett/Documents/Git/jsbandit/analysis/models/stan/bandit_stan_group_optim.stan"
# set working directory and load file
setwd(dataDir)
load(dataFile)
# recode choices from string to numeric
try(sorted.data[sorted.data$choice == "top",]$choice <- 1)
try(sorted.data[sorted.data$choice == "right",]$choice <- 2)
try(sorted.data[sorted.data$choice == "bottom",]$choice <- 3)
try(sorted.data[sorted.data$choice == "left",]$choice <- 4)
sorted.data$choice <- as.numeric(sorted.data$choice)
try(sorted.data[sorted.data$whichFilled == "none",]$whichFilled <- 0)
try(sorted.data[sorted.data$whichFilled == "top",]$whichFilled <- 1)
try(sorted.data[sorted.data$whichFilled == "right",]$whichFilled <- 2)
try(sorted.data[sorted.data$whichFilled == "bottom",]$whichFilled <- 3)
try(sorted.data[sorted.data$whichFilled == "left",]$whichFilled <- 4)
sorted.data$whichFilled <- as.numeric(sorted.data$whichFilled)
# extract the specified participant
IDs <- unique(sorted.data$ID)
subsetID <- IDs[participantNumbers]
extract <- subset(sorted.data, ID %in% subsetID)
nSubjects = length(participantNumbers)
# create data containers to pass to stan, and fill them
choices <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # choice data
points <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # points data
changeLag <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # change lag data
whichFilled <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # which changed data
# deal data to the arrays built above
for (p in 1:nSubjects){
choices[,,p] <- matrix(extract[extract$ID == subsetID[p],]$choice,nBlocks,nTrials,byrow = T)
points[,,p] <- matrix(extract[extract$ID == subsetID[p],]$pointsWon,nBlocks,nTrials,byrow = T)
changeLag[,,p] <- matrix(extract[extract$ID == subsetID[p],]$changeLag,nBlocks,nTrials,byrow = T)
whichFilled[,,p] <- matrix(extract[extract$ID == subsetID[p],]$whichFilled,nBlocks,nTrials,byrow = T)
}
# list data to be passed on to stan
data <- list(choices = choices,
whichFilled = whichFilled,
points = points,
nBandits = nBandits,
nBlocks = nBlocks,
nTrials = nTrials,
nSubjects = nSubjects,
# mean0 = mean0,
# variance0 = variance0,
changeLag = changeLag,
sigma_zeta = sigma_zeta
)
# list parameters to estimate in stan
parameters <- c("mu_sigma_epsilon",
"mu_b",
"mu_p",
"mu_q",
"mu_beta",
"sigma_sigma_epsilon",
"sigma_b",
"sigma_p",
"sigma_q",
"sigma_beta",
"sigma_epsilon",
"b",
"p",
"q",
"beta",
"mean0",
"variance0"
)
# set parallel options
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# set inits
myInits <- list(list(
mu_sigma_epsilon = 5,
mu_b = 5,
mu_p = 5,
mu_q = 5,
mu_beta = 5,
sigma_sigma_epsilon = 10,
sigma_b = 10,
sigma_p = 10,
sigma_q = 10,
sigma_beta = 1,
mean0 = 50,
variance0 = 1000
))
# Call stan
tic()
samples <- stan(file = stanFile,
data = data,
#init = myInits,  # If not specified, gives random inits
pars=parameters,
iter=500,
chains=1,
thin=1
# warmup = 100  # Stands for burn-in; Default = iter/2
# seed = 123  # Setting seed; Default is random seed
)
# clear workspace:
rm(list=ls())
# load rjags package
library(rstan)
library(tictoc)
# set a couple of helpful variables
participantNumbers <- 21:22 # which participants' data to test?
nTrials <- 30 # per block
nBlocks <- 3
nBandits <- 4
# mean0 <- 20
# variance0 <- 1000
sigma_zeta <- 5
# define working directory and datafile
dataDir <- "~/Documents/Git/jsbandit/data/"
dataFile <- "banditData_v2point2.RData"
stanFile <- "/Users/danielbennett/Documents/Git/jsbandit/analysis/models/stan/bandit_stan_group_optim.stan"
# set working directory and load file
setwd(dataDir)
load(dataFile)
# recode choices from string to numeric
try(sorted.data[sorted.data$choice == "top",]$choice <- 1)
try(sorted.data[sorted.data$choice == "right",]$choice <- 2)
try(sorted.data[sorted.data$choice == "bottom",]$choice <- 3)
try(sorted.data[sorted.data$choice == "left",]$choice <- 4)
sorted.data$choice <- as.numeric(sorted.data$choice)
try(sorted.data[sorted.data$whichFilled == "none",]$whichFilled <- 0)
try(sorted.data[sorted.data$whichFilled == "top",]$whichFilled <- 1)
try(sorted.data[sorted.data$whichFilled == "right",]$whichFilled <- 2)
try(sorted.data[sorted.data$whichFilled == "bottom",]$whichFilled <- 3)
try(sorted.data[sorted.data$whichFilled == "left",]$whichFilled <- 4)
sorted.data$whichFilled <- as.numeric(sorted.data$whichFilled)
# extract the specified participant
IDs <- unique(sorted.data$ID)
subsetID <- IDs[participantNumbers]
extract <- subset(sorted.data, ID %in% subsetID)
nSubjects = length(participantNumbers)
# create data containers to pass to stan, and fill them
choices <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # choice data
points <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # points data
changeLag <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # change lag data
whichFilled <- array(data = NA, dim = c(nBlocks,nTrials,nSubjects)) # which changed data
# deal data to the arrays built above
for (p in 1:nSubjects){
choices[,,p] <- matrix(extract[extract$ID == subsetID[p],]$choice,nBlocks,nTrials,byrow = T)
points[,,p] <- matrix(extract[extract$ID == subsetID[p],]$pointsWon,nBlocks,nTrials,byrow = T)
changeLag[,,p] <- matrix(extract[extract$ID == subsetID[p],]$changeLag,nBlocks,nTrials,byrow = T)
whichFilled[,,p] <- matrix(extract[extract$ID == subsetID[p],]$whichFilled,nBlocks,nTrials,byrow = T)
}
# list data to be passed on to stan
data <- list(choices = choices,
whichFilled = whichFilled,
points = points,
nBandits = nBandits,
nBlocks = nBlocks,
nTrials = nTrials,
nSubjects = nSubjects,
# mean0 = mean0,
# variance0 = variance0,
changeLag = changeLag,
sigma_zeta = sigma_zeta
)
# list parameters to estimate in stan
parameters <- c("sigma_epsilon",
# "mu_sigma_epsilon",
"mu_b",
"mu_p",
"mu_q",
"mu_beta",
# "sigma_sigma_epsilon",
"sigma_b",
"sigma_p",
"sigma_q",
"sigma_beta",
"sigma_epsilon",
"b",
"p",
"q",
"beta",
"mean0",
"variance0"
)
# set parallel options
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# set inits
myInits <- list(list(
# mu_sigma_epsilon = 5,
sigma_epsilon = 5,
mu_b = 5,
mu_p = 5,
mu_q = 5,
mu_beta = 5,
# sigma_sigma_epsilon = 10,
sigma_b = 10,
sigma_p = 10,
sigma_q = 10,
sigma_beta = 1,
mean0 = 50,
variance0 = 1000
))
# Call stan
tic()
samples <- stan(file = stanFile,
data = data,
#init = myInits,  # If not specified, gives random inits
pars=parameters,
iter=500,
chains=1,
thin=1
# warmup = 100  # Stands for burn-in; Default = iter/2
# seed = 123  # Setting seed; Default is random seed
)
toc()
install.packages("tictoc")
samples
traceplot(samples)
