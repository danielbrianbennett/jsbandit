for (i in 4){ # loop over subjects
for (j in 1:nRooms){
oCounter <- 1
iCounter <- 1
o_a <- 1
o_b <- 1
i_a <- 1
i_b <- 1
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
for (k in 1:nTrials){
trialData <- subset(learningData,learningData$subj == subs[i] & learningData$trialRoom == k & learningData$block == j)
if (substr(trialData$imageShown,1,1) == 'O'){
oCounter <- oCounter + 1
V_outdoor[j,oCounter,i] <- V_outdoor[j,oCounter-1,i] + eta * (trialData$reward - V_outdoor[j,oCounter-1,i])
estimate_outdoor[j,oCounter-1,i] <- trialData$estimate
o_a <- o_a + log(1 + (eta * trialData$reward))
o_b <- o_b + log(1 + (eta * (100 - trialData$reward)))
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
}else if(substr(trialData$imageShown,1,1) == 'I'){
iCounter <- iCounter + 1
V_indoor[j,iCounter,i] <- V_indoor[j,iCounter-1,i] + eta * (trialData$reward - V_indoor[j,iCounter-1,i])
estimate_indoor[j,oCounter-1,i] <- trialData$estimate
}
}
}
}
# load packages
library(VGAM)
# specify some important parameters
nTrials <- 30
nRooms <- 2
nCond <- 2
# temp - parameters
eta <- .5
# load data
learningData <- read.table("~/Desktop/challenge/learningTrials")
# reassign trial numbers to start at 1
learningData$trialExp <- learningData$trialExp + 1
learningData$trialRoom <- learningData$trialRoom + 1
# add block number
learningData$block <- ifelse(learningData$trialExp <= 30, 1, 2)
# calculate number of subjects
subs <- unique(learningData$subj)
nSub <- length(subs)
# initialise value containers
V_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_indoor[1:nRooms,1,1:nSub] <- 50
V_outdoor[1:nRooms,1,1:nSub] <- 50
# initialise estimate containers
estimate_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
estimate_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
for (i in 4){ # loop over subjects
for (j in 1:nRooms){
oCounter <- 1
iCounter <- 1
o_a <- 1
o_b <- 1
i_a <- 1
i_b <- 1
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
for (k in 1:nTrials){
trialData <- subset(learningData,learningData$subj == subs[i] & learningData$trialRoom == k & learningData$block == j)
if (substr(trialData$imageShown,1,1) == 'O'){
oCounter <- oCounter + 1
V_outdoor[j,oCounter,i] <- V_outdoor[j,oCounter-1,i] + eta * (trialData$reward - V_outdoor[j,oCounter-1,i])
estimate_outdoor[j,oCounter-1,i] <- trialData$estimate
o_a <- o_a + log(1 + (eta * trialData$reward))
o_b <- o_b + log(1 + (eta * (100 - trialData$reward)))
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
}else if(substr(trialData$imageShown,1,1) == 'I'){
iCounter <- iCounter + 1
V_indoor[j,iCounter,i] <- V_indoor[j,iCounter-1,i] + eta * (trialData$reward - V_indoor[j,iCounter-1,i])
estimate_indoor[j,oCounter-1,i] <- trialData$estimate
}
}
}
}
# load packages
library(VGAM)
# specify some important parameters
nTrials <- 30
nRooms <- 2
nCond <- 2
# temp - parameters
eta <- 10
# load data
learningData <- read.table("~/Desktop/challenge/learningTrials")
# reassign trial numbers to start at 1
learningData$trialExp <- learningData$trialExp + 1
learningData$trialRoom <- learningData$trialRoom + 1
# add block number
learningData$block <- ifelse(learningData$trialExp <= 30, 1, 2)
# calculate number of subjects
subs <- unique(learningData$subj)
nSub <- length(subs)
# initialise value containers
V_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_indoor[1:nRooms,1,1:nSub] <- 50
V_outdoor[1:nRooms,1,1:nSub] <- 50
# initialise estimate containers
estimate_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
estimate_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
for (i in 4){ # loop over subjects
for (j in 1:nRooms){
oCounter <- 1
iCounter <- 1
o_a <- 1
o_b <- 1
i_a <- 1
i_b <- 1
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
for (k in 1:nTrials){
trialData <- subset(learningData,learningData$subj == subs[i] & learningData$trialRoom == k & learningData$block == j)
if (substr(trialData$imageShown,1,1) == 'O'){
oCounter <- oCounter + 1
V_outdoor[j,oCounter,i] <- V_outdoor[j,oCounter-1,i] + eta * (trialData$reward - V_outdoor[j,oCounter-1,i])
estimate_outdoor[j,oCounter-1,i] <- trialData$estimate
o_a <- o_a + log(1 + (eta * trialData$reward))
o_b <- o_b + log(1 + (eta * (100 - trialData$reward)))
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
}else if(substr(trialData$imageShown,1,1) == 'I'){
iCounter <- iCounter + 1
V_indoor[j,iCounter,i] <- V_indoor[j,iCounter-1,i] + eta * (trialData$reward - V_indoor[j,iCounter-1,i])
estimate_indoor[j,oCounter-1,i] <- trialData$estimate
}
}
}
}
# load packages
library(VGAM)
# specify some important parameters
nTrials <- 30
nRooms <- 2
nCond <- 2
# temp - parameters
eta <- 10
# load data
learningData <- read.table("~/Desktop/challenge/learningTrials")
# reassign trial numbers to start at 1
learningData$trialExp <- learningData$trialExp + 1
learningData$trialRoom <- learningData$trialRoom + 1
# add block number
learningData$block <- ifelse(learningData$trialExp <= 30, 1, 2)
# calculate number of subjects
subs <- unique(learningData$subj)
nSub <- length(subs)
# initialise value containers
V_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_indoor[1:nRooms,1,1:nSub] <- 50
V_outdoor[1:nRooms,1,1:nSub] <- 50
# initialise estimate containers
estimate_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
estimate_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
for (i in 1){ # loop over subjects
for (j in 1:nRooms){
oCounter <- 1
iCounter <- 1
o_a <- 1
o_b <- 1
i_a <- 1
i_b <- 1
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
for (k in 1:nTrials){
trialData <- subset(learningData,learningData$subj == subs[i] & learningData$trialRoom == k & learningData$block == j)
if (substr(trialData$imageShown,1,1) == 'O'){
oCounter <- oCounter + 1
V_outdoor[j,oCounter,i] <- V_outdoor[j,oCounter-1,i] + eta * (trialData$reward - V_outdoor[j,oCounter-1,i])
estimate_outdoor[j,oCounter-1,i] <- trialData$estimate
o_a <- o_a + log(1 + (eta * trialData$reward))
o_b <- o_b + log(1 + (eta * (100 - trialData$reward)))
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
}else if(substr(trialData$imageShown,1,1) == 'I'){
iCounter <- iCounter + 1
V_indoor[j,iCounter,i] <- V_indoor[j,iCounter-1,i] + eta * (trialData$reward - V_indoor[j,iCounter-1,i])
estimate_indoor[j,oCounter-1,i] <- trialData$estimate
}
}
}
}
# load packages
library(VGAM)
# specify some important parameters
nTrials <- 30
nRooms <- 2
nCond <- 2
# temp - parameters
eta <- .5
# load data
learningData <- read.table("~/Desktop/challenge/learningTrials")
# reassign trial numbers to start at 1
learningData$trialExp <- learningData$trialExp + 1
learningData$trialRoom <- learningData$trialRoom + 1
# add block number
learningData$block <- ifelse(learningData$trialExp <= 30, 1, 2)
# calculate number of subjects
subs <- unique(learningData$subj)
nSub <- length(subs)
# initialise value containers
V_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_indoor[1:nRooms,1,1:nSub] <- 50
V_outdoor[1:nRooms,1,1:nSub] <- 50
# initialise estimate containers
estimate_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
estimate_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
for (i in 1){ # loop over subjects
for (j in 1:nRooms){
oCounter <- 1
iCounter <- 1
o_a <- 1
o_b <- 1
i_a <- 1
i_b <- 1
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
for (k in 1:nTrials){
trialData <- subset(learningData,learningData$subj == subs[i] & learningData$trialRoom == k & learningData$block == j)
if (substr(trialData$imageShown,1,1) == 'O'){
oCounter <- oCounter + 1
V_outdoor[j,oCounter,i] <- V_outdoor[j,oCounter-1,i] + eta * (trialData$reward - V_outdoor[j,oCounter-1,i])
estimate_outdoor[j,oCounter-1,i] <- trialData$estimate
o_a <- o_a + log(1 + (eta * trialData$reward))
o_b <- o_b + log(1 + (eta * (100 - trialData$reward)))
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
}else if(substr(trialData$imageShown,1,1) == 'I'){
iCounter <- iCounter + 1
V_indoor[j,iCounter,i] <- V_indoor[j,iCounter-1,i] + eta * (trialData$reward - V_indoor[j,iCounter-1,i])
estimate_indoor[j,oCounter-1,i] <- trialData$estimate
}
}
}
}
log(1 + .5)
# load packages
library(VGAM)
# specify some important parameters
nTrials <- 30
nRooms <- 2
nCond <- 2
# temp - parameters
eta <- .01
# load data
learningData <- read.table("~/Desktop/challenge/learningTrials")
# reassign trial numbers to start at 1
learningData$trialExp <- learningData$trialExp + 1
learningData$trialRoom <- learningData$trialRoom + 1
# add block number
learningData$block <- ifelse(learningData$trialExp <= 30, 1, 2)
# calculate number of subjects
subs <- unique(learningData$subj)
nSub <- length(subs)
# initialise value containers
V_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond) + 1, nSub))
V_indoor[1:nRooms,1,1:nSub] <- 50
V_outdoor[1:nRooms,1,1:nSub] <- 50
# initialise estimate containers
estimate_indoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
estimate_outdoor <- array(data = NA, dim = c(nRooms, (nTrials/nCond), nSub))
for (i in 1){ # loop over subjects
for (j in 1:nRooms){
oCounter <- 1
iCounter <- 1
o_a <- 1
o_b <- 1
i_a <- 1
i_b <- 1
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
for (k in 1:nTrials){
trialData <- subset(learningData,learningData$subj == subs[i] & learningData$trialRoom == k & learningData$block == j)
if (substr(trialData$imageShown,1,1) == 'O'){
oCounter <- oCounter + 1
V_outdoor[j,oCounter,i] <- V_outdoor[j,oCounter-1,i] + eta * (trialData$reward - V_outdoor[j,oCounter-1,i])
estimate_outdoor[j,oCounter-1,i] <- trialData$estimate
o_a <- o_a + log(1 + (eta * trialData$reward))
o_b <- o_b + log(1 + (eta * (100 - trialData$reward)))
plot(dbetabinom.ab(0:10,10,o_a,o_b),ylim = range(0,.5))
readline()
}else if(substr(trialData$imageShown,1,1) == 'I'){
iCounter <- iCounter + 1
V_indoor[j,iCounter,i] <- V_indoor[j,iCounter-1,i] + eta * (trialData$reward - V_indoor[j,iCounter-1,i])
estimate_indoor[j,oCounter-1,i] <- trialData$estimate
}
}
}
}
log(c(.01, .01, .01))
-log(c(.01, .01, .01))
sum(-log(c(.01, .01, .01)))
sum(-log(c(.1, .1, .1)))
-log(c(.1, .1, .1))
exp(-7/60)
c
c(1:100)
thing <- c(1:100)
thing(1) = []
rm(thing(1))
thing(1) <- NULL
thing
thing[-1]
thing[-1 -3]
thing[c(-1, -3)]
# clear workspace:
rm(list=ls())
# load rjags package
library(R2jags)
# set a couple of helpful variables
participantID <- 10308915 # which participant's data to test?
nTrials <- 30 # per block
nBlocks <- 3
nBandits <- 4
mean0 <- 0
variance0 <- 1000
fudgeFactor <- .00001
# define working directory and datafile
dataDir <- "~/Google Drive/Works in Progress/JSBANDIT/Bandit/data/Bandit project shared data/"
dataFile <- "banditData_v2point2.RData"
bugsFile <- "~/Documents/Git/bandit-jags/bandit_jags_single.txt"
# set working directory and load file
setwd(dataDir)
load(dataFile)
# extract the specified participant
subsetID <- participantID
extract <- subset(sorted.data, ID %in% subsetID)
# recode choices from string to numeric
extract$choice[extract$choice == "top"] = 1
extract$choice[extract$choice == "right"] = 2
extract$choice[extract$choice == "bottom"] = 3
extract$choice[extract$choice == "left"] = 4
extract$choice <- as.numeric(extract$choice)
extract$whichFilled[extract$whichFilled == "none"] = 0
extract$whichFilled[extract$whichFilled == "top"] = 1
extract$whichFilled[extract$whichFilled == "right"] = 2
extract$whichFilled[extract$whichFilled == "bottom"] = 3
extract$whichFilled[extract$whichFilled == "left"] = 4
extract$whichFilled <- as.numeric(extract$whichFilled)
# recode negative change lags
extract$changeLag[extract$changeLag < 0] <- fudgeFactor
# create data containers to pass to jags, and fill them
choices <- array(data = NA, dim = c(nBlocks,nTrials)) # choice data
points <- array(data = NA, dim = c(nBlocks,nTrials)) # points data
changeLag <- matrix(extract[extract$ID == subsetID,]$changeLag,nBlocks,nTrials,byrow = T) # record how long since change
choices[,] <- matrix(extract[extract$ID == subsetID,]$choice,nBlocks,nTrials,byrow = T)
points[,] <- matrix(extract[extract$ID == subsetID,]$pointsWon,nBlocks,nTrials,byrow = T)
whichFilled <- matrix(extract[extract$ID == subsetID,]$whichFilled,nBlocks,nTrials,byrow = T)
# list data to be passed on to JAGS
data <- list("choices",
"changeLag",
"nBandits",
"nBlocks",
"nTrials",
"points",
"whichFilled",
"mean0",
"variance0",
"fudgeFactor"
)
# list parameters to estimate in JAGS
parameters <- c("sigma_zeta",
"sigma_epsilon",
"b",
"p",
"q"
)
# initial values of parameters
initVals <-	list(list(
sigma_zeta = 10,
sigma_epsilon = 10,
b = 10,
p = .1,
q = .1
))
# call jags
samples <- jags(data, inits=initVals, parameters, model.file = bugsFile,
n.chains=1, n.iter=5000, n.burnin=2000, n.thin=1)
install.packages("Rajgs")
install.packages("Rjags")
install.packages("R2jags")
install.packages("R2jags")
install.packages("rjags")
install.packages("ggplot2")
# clear workspace:
rm(list=ls())
# load rjags package
library(rstan)
library(tictoc)
# set a couple of helpful variables
participantNumbers <- 1:149 # which participants' data to test?
nTrials <- 30 # per block
nBlocks <- 3
nBandits <- 4
sigma_zeta <- 8
# define working directory and datafile
dataDir <- "~/Documents/Git/jsbandit/data/"
dataFile <- "banditData_v2point2.RData"
stanFile <- "/Users/danielbennett/Documents/Git/jsbandit/analysis/models/stan/bandit_stan_group_vector.stan"
# set working directory and load file
setwd(dataDir)
load(dataFile)
# recode choices from string to numeric
try(sorted.data[sorted.data$choice == "top",]$choice <- 1)
try(sorted.data[sorted.data$choice == "right",]$choice <- 2)
try(sorted.data[sorted.data$choice == "bottom",]$choice <- 3)
try(sorted.data[sorted.data$choice == "left",]$choice <- 4)
sorted.data$choice <- as.numeric(sorted.data$choice)
try(sorted.data[sorted.data$whichFilled == "none",]$whichFilled <- 0)
try(sorted.data[sorted.data$whichFilled == "top",]$whichFilled <- 1)
try(sorted.data[sorted.data$whichFilled == "right",]$whichFilled <- 2)
try(sorted.data[sorted.data$whichFilled == "bottom",]$whichFilled <- 3)
try(sorted.data[sorted.data$whichFilled == "left",]$whichFilled <- 4)
sorted.data$whichFilled <- as.numeric(sorted.data$whichFilled)
# extract the specified participant
IDs <- unique(sorted.data$ID)
subsetID <- IDs[participantNumbers]
extract <- subset(sorted.data, ID %in% subsetID)
nSubjects = length(participantNumbers)
# create data containers to pass to stan, and fill them
choices <- array(data = NA, dim = c(nSubjects,nBlocks,nTrials)) # choice data
points <- array(data = NA, dim = c(nSubjects,nBlocks,nTrials)) # points data
changeLag <- array(data = NA, dim = c(nSubjects,nBlocks,nTrials)) # change lag data
whichFilled <- array(data = NA, dim = c(nSubjects,nBlocks,nTrials)) # which changed data
# deal data to the arrays built above
for (p in 1:nSubjects){
choices[p,,] <- matrix(extract[extract$ID == subsetID[p],]$choice,nBlocks,nTrials,byrow = T)
points[p,,] <- matrix(extract[extract$ID == subsetID[p],]$pointsWon,nBlocks,nTrials,byrow = T)
changeLag[p,,] <- matrix(extract[extract$ID == subsetID[p],]$changeLag,nBlocks,nTrials,byrow = T)
whichFilled[p,,] <- matrix(extract[extract$ID == subsetID[p],]$whichFilled,nBlocks,nTrials,byrow = T)
}
# list data to be passed on to stan
data <- list(choices = choices,
whichFilled = whichFilled,
points = points,
nBandits = nBandits,
nBlocks = nBlocks,
nTrials = nTrials,
nSubjects = nSubjects,
changeLag = changeLag,
sigma_zeta = sigma_zeta
)
# list parameters to estimate in stan
parameters <- c("sigma_epsilon",
"mu_b",
"mu_p",
"mu_q",
"mu_beta",
"sigma_b",
"sigma_p",
"sigma_q",
"sigma_beta",
"sigma_epsilon",
"mean0",
"variance0",
"b",
"p",
"q",
"beta"
)
# set parallel options
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# set inits
load("~/Documents/Git/jsbandit/analysis/models/stan/savedInitVals.RData")
initVals <- list(
sigma_epsilon = savedInitVals$sigma_epsilon,
mu_b = 0,
mu_p = 0,
mu_q = 0,
mu_beta = savedInitVals$mu_beta,
sigma_b = 20,
sigma_p = 20,
sigma_q = 20,
sigma_beta = savedInitVals$sigma_beta,
mean0 = savedInitVals$mean0,
variance0 = savedInitVals$variance0,
b = savedInitVals$b,
p = savedInitVals$p,
q = savedInitVals$q,
beta = savedInitVals$beta
)
myInits <- list(initVals,initVals)
# Call stan
tic()
samples <- stan(file = stanFile,
data = data,
init = myInits,  # If not specified, gives random inits
pars=parameters,
iter=5000,
chains=2,
thin=1,
warmup = 1000  # Default = iter/2
# seed = 123  # Setting seed; Default is random seed
)
toc()
traceplot(samples)
samples
?pairs
samples$mu_b
samples@mu_b
samples
